"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveSimilarity = exports.getRoot = exports.getChunks = void 0;
function getChunks(input) {
    const CHUNK_SIZE = 3;
    const chunks = [];
    let currentChunk = 1;
    while ((currentChunk - 1) * CHUNK_SIZE < input.length) {
        chunks.push(input.substring((currentChunk - 1) * CHUNK_SIZE, currentChunk * CHUNK_SIZE));
        currentChunk++;
    }
    return makeIterator(chunks);
}
exports.getChunks = getChunks;
const makeIterator = (array) => {
    let nextIndex = 0;
    return {
        next: () => {
            return nextIndex < array.length
                ? { value: array[nextIndex++], done: false }
                : { done: true };
        },
    };
};
function getRoot(base, newToken) {
    var _a;
    const chunks = getChunks(newToken);
    let currentChunk = chunks.next().value;
    let root = '';
    while (currentChunk && base.includes(root + currentChunk)) {
        root += currentChunk;
        currentChunk = chunks.next().value;
    }
    if (root === '')
        return '';
    const subChunk = makeIterator((_a = currentChunk === null || currentChunk === void 0 ? void 0 : currentChunk.split('')) !== null && _a !== void 0 ? _a : []);
    let currentSubItem = subChunk.next().value;
    while (currentSubItem && base.includes(root + currentSubItem)) {
        root += currentSubItem;
        currentSubItem = subChunk.next().value;
    }
    return root;
}
exports.getRoot = getRoot;
function resolveSimilarity(base, newToken) {
    const root = getRoot(base, newToken);
    return newToken.length > base.length
        ? root.length / newToken.length
        : root.length / base.length;
}
exports.resolveSimilarity = resolveSimilarity;
